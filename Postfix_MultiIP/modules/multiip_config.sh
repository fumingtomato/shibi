#!/bin/bash

# =================================================================
# MULTI-IP CONFIGURATION MODULE
# IP detection, network interface setup, rotation configuration
# =================================================================

# Function to get all server IPs
get_all_server_ips() {
    print_header "Detecting Server IP Addresses"
    
    local all_ips=$(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '127.0.0.1')
    
    print_message "Detected IP addresses on this server:"
    echo "$all_ips"
    
    PRIMARY_IP=$(get_public_ip)
    print_message "Primary public IP: $PRIMARY_IP"
    
    print_message "\nDo you want to configure multiple IP addresses for bulk mailing?"
    read -p "Enter 'yes' to configure multiple IPs, or 'no' for single IP setup: " multi_ip_choice
    
    if [[ "$multi_ip_choice" == "yes" || "$multi_ip_choice" == "y" ]]; then
        print_message "\nEnter each IP address you want to use for sending mail."
        print_message "Press Enter with empty input when done."
        
        IP_ADDRESSES+=("$PRIMARY_IP")
        IP_COUNT=1
        
        while true; do
            read -p "Enter IP address #$((IP_COUNT + 1)) (or press Enter to finish): " ip_addr
            
            if [ -z "$ip_addr" ]; then
                break
            fi
            
            if [[ $ip_addr =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
                if ip addr show | grep -q "$ip_addr"; then
                    IP_ADDRESSES+=("$ip_addr")
                    IP_COUNT=$((IP_COUNT + 1))
                    print_message "Added IP: $ip_addr"
                else
                    print_warning "IP $ip_addr is not configured on this server. Skipping."
                fi
            else
                print_error "Invalid IP format. Please enter a valid IPv4 address."
            fi
        done
    else
        IP_ADDRESSES+=("$PRIMARY_IP")
        IP_COUNT=1
    fi
    
    export IP_ADDRESSES
    export IP_COUNT
    print_message "\nConfigured ${IP_COUNT} IP address(es) for mail server."
}

# Configure network interfaces for multiple IPs
configure_network_interfaces() {
    print_header "Configuring Network Interfaces for Multiple IPs"
    
    if [ ${#IP_ADDRESSES[@]} -le 1 ]; then
        print_message "Single IP configuration - skipping network interface setup"
        return
    fi
    
    local primary_interface=$(ip route | grep default | awk '{print $5}' | head -1)
    print_message "Primary network interface: $primary_interface"
    
    print_message "Creating persistent network configuration..."
    
    backup_config "network" "/etc/network/interfaces"
    
    cat > /etc/network/interfaces.d/50-multi-ip.cfg <<EOF
# Multi-IP configuration for bulk mail server
# Generated by $INSTALLER_NAME v$INSTALLER_VERSION
# Date: $(date)

EOF
    
    local ip_index=0
    for ip in "${IP_ADDRESSES[@]:1}"; do
        ip_index=$((ip_index + 1))
        
        read -p "Enter subnet mask for $ip (e.g., 255.255.255.0 or 24): " subnet
        
        if [[ "$subnet" =~ ^[0-9]+$ ]]; then
            cidr=$subnet
            case $cidr in
                24) netmask="255.255.255.0" ;;
                25) netmask="255.255.255.128" ;;
                26) netmask="255.255.255.192" ;;
                27) netmask="255.255.255.224" ;;
                28) netmask="255.255.255.240" ;;
                29) netmask="255.255.255.248" ;;
                30) netmask="255.255.255.252" ;;
                *) netmask="255.255.255.0" ;;
            esac
        else
            netmask=$subnet
        fi
        
        cat >> /etc/network/interfaces.d/50-multi-ip.cfg <<EOF
auto ${primary_interface}:${ip_index}
iface ${primary_interface}:${ip_index} inet static
    address $ip
    netmask $netmask

EOF
    done
    
    print_message "Network interface configuration created"
    print_warning "You may need to restart networking or reboot for all IPs to become active"
}

# Create IP rotation configuration
create_ip_rotation_config() {
    print_header "Creating IP Rotation Configuration"
    
    if [ ${#IP_ADDRESSES[@]} -le 1 ]; then
        print_message "Single IP configuration - IP rotation not needed"
        return
    fi
    
    mkdir -p /etc/postfix/transport_maps
    
    print_message "Creating sender-dependent transport configuration..."
    
    cat > /etc/postfix/sender_dependent_default_transport_maps <<EOF
# Sender-dependent transport configuration for IP rotation
# Generated by $INSTALLER_NAME v$INSTALLER_VERSION

EOF
    
    local transport_index=0
    for ip in "${IP_ADDRESSES[@]}"; do
        transport_index=$((transport_index + 1))
        local transport_name="smtp-ip${transport_index}"
        
        print_message "\nConfiguring IP: $ip"
        read -p "Enter domain(s) to send from this IP (comma-separated, or 'all' for round-robin): " ip_domains
        
        if [ "$ip_domains" == "all" ]; then
            echo "# IP $ip - Used for round-robin delivery" >> /etc/postfix/sender_dependent_default_transport_maps
        else
            IFS=',' read -ra DOMAINS <<< "$ip_domains"
            for domain in "${DOMAINS[@]}"; do
                domain=$(echo "$domain" | xargs)
                echo "@${domain}    ${transport_name}:" >> /etc/postfix/sender_dependent_default_transport_maps
            done
        fi
    done
    
    create_random_transport_selector
    
    print_message "IP rotation configuration created"
}

# Create random transport selector script
create_random_transport_selector() {
    cat > /usr/local/bin/postfix-random-transport <<'EOF'
#!/bin/bash
# Random transport selector for load balancing

transports=()
for i in {1..20}; do
    if grep -q "smtp-ip${i}" /etc/postfix/master.cf; then
        transports+=("smtp-ip${i}")
    fi
done

if [ ${#transports[@]} -gt 0 ]; then
    random_index=$((RANDOM % ${#transports[@]}))
    echo "${transports[$random_index]}:"
else
    echo "smtp:"
fi
EOF
    
    chmod +x /usr/local/bin/postfix-random-transport
}

# Configure reverse DNS instructions
create_ptr_instructions() {
    local output_file="/root/ptr-records-setup.txt"
    
    cat > "$output_file" <<EOF
==========================================================
REVERSE DNS (PTR) RECORDS CONFIGURATION
==========================================================

IMPORTANT: PTR records must be configured with your hosting provider.
They cannot be set through Cloudflare or standard DNS management.

Your IP addresses and suggested PTR records:

EOF
    
    local idx=1
    for ip in "${IP_ADDRESSES[@]}"; do
        cat >> "$output_file" <<EOF
IP Address #$idx: $ip
Suggested PTR: mail${idx}.$DOMAIN_NAME

EOF
        idx=$((idx + 1))
    done
    
    cat >> "$output_file" <<EOF
==========================================================
HOW TO CONFIGURE:

1. Contact your hosting provider's support
2. Request PTR record configuration for each IP
3. Provide the IP address and desired hostname
4. Wait for confirmation (usually 24-48 hours)

VERIFICATION:

Once configured, verify with:
dig -x IP_ADDRESS

or:
host IP_ADDRESS

==========================================================
EOF
    
    print_message "PTR record instructions saved to $output_file"
}

export -f get_all_server_ips configure_network_interfaces create_ip_rotation_config
export -f create_random_transport_selector create_ptr_instructions
